# 자료구조 (Data Structures)

## 학습 목표

이 폴더에서는 C#으로 구현된 기본 자료구조를 학습합니다.
- 연결 리스트(LinkedList)의 개념과 구조 이해
- 스택(Stack)의 LIFO 원리와 활용 방법 학습
- 각 자료구조의 시간 복잡도와 효율성 분석
- 실무에서의 활용 사례 이해

---

## 프로젝트 구조

```
05_DataStructures/
├── LinkedList/
│   ├── Program.cs          # 연결 리스트 구현 및 예제
│   └── LinkedList.csproj   # 프로젝트 파일
├── Stack/
│   ├── Program.cs          # 스택 구현 및 예제
│   └── Stack.csproj        # 프로젝트 파일
└── README.md               # 이 문서
```

---

## 1. 연결 리스트 (Linked List)

### 개념

연결 리스트는 데이터를 노드(Node)라는 단위로 저장하고, 각 노드가 다음 노드의 주소를 가지고 있는 자료구조입니다.

**노드(Node)의 구성**
- 데이터 필드: 실제 저장할 값
- 포인터 필드: 다음/이전 노드로 가는 주소 (Next, Prev)

### 연결 리스트의 종류

#### 1) 단일 연결 리스트 (Singly Linked List)
- 구조: `Data -> Next`
- 특징: 한 방향으로만 탐색 가능

#### 2) 이중 연결 리스트 (Doubly Linked List)
- 구조: `Prev <- Data -> Next`
- 특징: 앞/뒤 양방향 탐색 가능
- C#에서는 `System.Collections.Generic.LinkedList<T>` 클래스로 제공
- 각 노드는 `LinkedListNode<T>` 객체로 표현

#### 3) 원형 연결 리스트 (Circular Linked List)
- 구조: 마지막 노드가 첫 노드와 연결
- 특징: 순환 구조로 무한 루프 순회 가능

### 주요 메서드

```csharp
LinkedList<string> list = new LinkedList<string>();

// 추가
list.AddLast("A");          // 맨 뒤에 추가
list.AddFirst("HEAD");      // 맨 앞에 추가
var nodeA = list.Find("A"); // 노드 찾기
list.AddAfter(nodeA, "C");  // 특정 노드 뒤에 추가
list.AddBefore(nodeA, "B"); // 특정 노드 앞에 추가

// 삭제
list.Remove("A");           // 특정 값 삭제
list.RemoveFirst();         // 맨 앞 삭제
list.RemoveLast();          // 맨 뒤 삭제

// 조회
int count = list.Count;     // 노드 개수
```

### 장단점

**장점**
1. 동적 크기 조절 가능 - 메모리 효율적 사용
2. 삽입/삭제가 빠름 - 포인터(주소)만 수정하면 됨
3. 다양한 변형 가능 - 단일, 이중, 원형 등 구조 확장 가능

**단점**
1. 임의 접근 불가 - 특정 위치 탐색 시 맨 앞(First)부터 화살표(Next)를 n번 따라가야 함
2. 추가 메모리 필요 - Next/Prev 포인터(주소) 저장 공간 필요
3. 캐시 효율 낮음 - 배열보다 실제 실행 속도가 느릴 수 있음

### 활용 사례

1. 삽입/삭제가 잦은 상황
2. 동적 크기가 필요할 때
3. 양방향 탐색이 필요한 경우 (이중 연결 리스트)
4. 순환 구조가 필요한 경우 (원형 연결 리스트)
5. 다른 자료구조의 기반 - 스택, 큐, 그래프 인접 리스트 등

### 시간 복잡도

| 연산 | 시간 복잡도 | 설명 |
|------|-------------|------|
| 맨 앞 추가 (AddFirst) | O(1) | Head 포인터만 수정 |
| 맨 뒤 추가 (AddLast) | O(1) | Tail 포인터만 수정 |
| 중간 삽입 (AddAfter/Before) | O(1) | 해당 노드를 이미 알고 있는 경우 |
| 탐색 (Find) | O(n) | 처음부터 순차 탐색 필요 |
| 삭제 (Remove) | O(n) | 탐색 후 삭제 |
| 특정 인덱스 접근 | O(n) | 배열과 달리 직접 접근 불가 |

---

## 2. 스택 (Stack)

### 개념

스택은 데이터를 쌓아올리는 자료구조로, LIFO(Last-In-First-Out) 원리를 따릅니다.

**규칙: LIFO (Last-In-First-Out)**
- 마지막에 들어간 데이터가 가장 먼저 나옴
- 접시를 쌓아두고 위에서부터 꺼내는 것과 같은 구조

### 주요 메서드

```csharp
Stack<int> st = new Stack<int>();

// 데이터 삽입
st.Push(10);     // 스택에 10 추가
st.Push(20);     // 스택에 20 추가
st.Push(30);     // 스택에 30 추가

// 데이터 확인 (삭제 없음)
int top = st.Peek();  // 최상단 데이터 확인 (30 반환)

// 데이터 꺼내기 (삭제)
int value = st.Pop(); // 최상단 데이터 제거 후 반환 (30 반환)

// 기타
int count = st.Count; // 스택에 있는 데이터 개수
st.Clear();           // 스택 비우기 (전부 삭제)
```

### 장단점

**장점**
1. 구현이 쉽고 간단함
2. Push/Pop 연산 속도가 빠름 (O(1))
3. 메모리 관리가 효율적

**단점**
1. 중간에 위치한 데이터로의 접근이 느림
2. 크기가 고정된 배열 기반 스택의 경우 오버플로 발생 가능
3. LIFO 구조 특성상 먼저 넣은 데이터 접근이 어려움

### 내부 동작 방식

#### 1) 배열 기반 스택
- 고정된 크기의 배열 사용
- 크기 제한 존재
- 캐시 효율이 좋음

#### 2) 연결 리스트 기반 스택
- 노드를 계속 추가하여 크기 제한 없이 사용 가능
- 동적 메모리 할당
- C#의 `Stack<T>`는 내부적으로 배열을 사용하며 필요시 자동으로 크기 확장

### 주의사항

**1. 스택 오버플로 (Stack Overflow)**
- 크기가 정해진 스택이 꽉 찼는데 더 넣으려고 할 때 발생
- 보통 배열 기반 스택에서 자주 발생
- C#의 `Stack<T>`는 자동으로 크기를 확장하므로 일반적으로 발생하지 않음

**2. 스택 언더플로 (Stack Underflow)**
- 비어 있는 스택에서 Pop()을 호출할 때 발생
- `InvalidOperationException` 예외 발생

```csharp
// 언더플로 방지 예제
if (st.Count > 0)
{
    int value = st.Pop();
}
```

### 활용 사례

1. **브라우저 뒤로 가기**
   - 가장 최근 방문한 페이지로 돌아가기

2. **실행 취소 (Undo)**
   - 가장 최근 작업을 취소

3. **함수 호출 스택**
   - 프로그램 실행 시 함수 호출 순서 관리

4. **괄호 검사**
   - 수식의 괄호가 올바르게 짝지어졌는지 확인

5. **깊이 우선 탐색 (DFS)**
   - 그래프나 트리 탐색 알고리즘

### 시간 복잡도

| 연산 | 시간 복잡도 | 설명 |
|------|-------------|------|
| Push | O(1) | 최상단에 추가 |
| Pop | O(1) | 최상단에서 제거 |
| Peek | O(1) | 최상단 확인 |
| Search | O(n) | 특정 데이터 탐색 |
| Clear | O(n) | 모든 데이터 제거 |

---

## 자료구조 비교

### 배열 vs 리스트 vs 연결 리스트

| 자료구조 | 크기 | 접근 속도 | 삽입/삭제 | 사용 케이스 |
|----------|------|-----------|-----------|-------------|
| 배열 (Array) | 고정 | O(1) | O(n) | 크기가 정해진 경우, 빠른 접근 필요 |
| 리스트 (List<T>) | 동적 | O(1) | O(n) | 가장 범용적, 크기 자동 관리 + 빠른 접근 |
| 연결 리스트 (LinkedList<T>) | 동적 | O(n) | O(1) | 삽입/삭제가 많거나 순환 구조 필요 |

### 스택 vs 큐

| 특성 | 스택 (Stack) | 큐 (Queue) |
|------|-------------|-----------|
| 원리 | LIFO (Last-In-First-Out) | FIFO (First-In-First-Out) |
| 주요 메서드 | Push, Pop, Peek | Enqueue, Dequeue, Peek |
| 활용 | 뒤로 가기, 실행 취소, DFS | 대기열, 너비 우선 탐색(BFS) |

---

## 실행 방법

### LinkedList 프로젝트 실행

```bash
cd /Users/yundonghee/Desktop/codingon/수업/SFS07th/05_DataStructures/LinkedList
dotnet run
```

**출력 예시:**
```
앞에서부터 출력:
A <-> B <-> C <-> null
뒤에서부터 출력:
C <-> B <-> A <-> null
HEAD -> A -> C -> B -> null
남은 노드 수: 1
```

### Stack 프로젝트 실행

```bash
cd /Users/yundonghee/Desktop/codingon/수업/SFS07th/05_DataStructures/Stack
dotnet run
```

**출력 예시:**
```
After Push: Count = 3
Peek = 30
After Peek: Count = 3
Pop = 30
Pop = 20
After Pop x2: Count = 1
After Clear: Count = 0
After Clear: Count = 0
```

---

## 추가 학습 자료

### 다음 단계 학습 주제

1. **큐 (Queue)**
   - FIFO 구조
   - 대기열 시스템 구현

2. **우선순위 큐 (Priority Queue)**
   - 우선순위에 따른 처리
   - 힙(Heap) 자료구조 활용

3. **양방향 큐 (Deque - Double-Ended Queue)**
   - 양쪽 끝에서 삽입/삭제 가능
   - 스택과 큐의 혼합

4. **해시 테이블 (Dictionary, HashSet)**
   - O(1) 시간 복잡도의 탐색
   - 빠른 데이터 검색

5. **트리 (Tree)**
   - 계층적 데이터 구조
   - 이진 트리, 이진 탐색 트리

6. **그래프 (Graph)**
   - 네트워크 구조 표현
   - 인접 리스트, 인접 행렬

7. **힙 (Heap)**
   - 완전 이진 트리
   - 우선순위 큐 구현

### 시간 복잡도 분석

효율적인 알고리즘 선택을 위해 시간 복잡도를 이해하는 것이 중요합니다:

- **O(1)**: 상수 시간 - 가장 효율적
- **O(log n)**: 로그 시간 - 매우 효율적 (이진 탐색)
- **O(n)**: 선형 시간 - 보통 (순차 탐색)
- **O(n log n)**: 선형 로그 시간 - 효율적인 정렬
- **O(n²)**: 이차 시간 - 비효율적 (중첩 루프)

### 학습 팁

1. **직접 구현해보기**: 내장 클래스를 사용하기 전에 직접 구현해보면 내부 동작 원리를 이해할 수 있습니다.

2. **시각화**: 자료구조의 동작을 그림으로 그려보면 이해가 쉬워집니다.

3. **실제 문제 해결**: 알고리즘 문제를 풀어보며 적절한 자료구조 선택 능력을 키웁니다.

4. **성능 측정**: 실제 코드에서 각 자료구조의 성능을 측정해보며 차이를 체감합니다.

---

## 참고 사항

- 모든 프로젝트는 .NET 8.0을 타겟으로 합니다.
- C#의 제네릭 컬렉션(`System.Collections.Generic`)을 활용합니다.
- 실무에서는 직접 구현보다는 .NET에서 제공하는 컬렉션 클래스를 사용하는 것이 권장됩니다.
- 각 자료구조의 특성을 이해하고 상황에 맞게 선택하는 것이 중요합니다.
